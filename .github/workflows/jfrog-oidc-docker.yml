name: "JFrog OIDC CI Workflow with Full Security Scan (Docker)"

on:
  push:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  PYTHON_VERSION: ${{ vars.PYTHON_VERSION || '3.11' }}
  BUILD_NAME: ${{ vars.BUILD_NAME || 'jfrog-docker-security-scan-build' }}
  BUILD_NUMBER: ${{ vars.BUILD_NUMBER || github.run_id }}
  # Artifactory repos / registry
  GENERIC_REPO: ${{ vars.GENERIC_REPO || 'my-generic-repo' }}
  DOCKER_REPO:  ${{ vars.DOCKER_REPO  || 'myrepo-docker' }}     # <-- you created this
  JF_REGISTRY:  ${{ vars.JF_REGISTRY  || 'aboavent.jfrog.io' }} # host ONLY (no https)
  # Scanning behavior
  FAIL_ON_SEVERITY: ${{ vars.FAIL_ON_SEVERITY || 'none' }}       # none|low|medium|high|critical
  XRAY_FORMAT: table
  # Upload filters (not used here, kept for parity)
  UPLOAD_PATTERN: ${{ vars.UPLOAD_PATTERN || '**/*' }}
  UPLOAD_EXCLUSIONS: ${{ vars.UPLOAD_EXCLUSIONS || '**/.git/**;**/.github/**;**/.jfrog/**' }}

jobs:
  build-scan-and-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup JFrog CLI (OIDC)
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JF_URL }}                      # e.g., https://aboavent.jfrog.io
        with:
          oidc-provider-name: github-oidc-integration

      - name: Ensure jq is available
        shell: bash
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y jq
          fi

      # NICE-TO-HAVE: fail early if the Docker repo doesn't exist
      - name: "Sanity: verify Artifactory Docker repo exists"
        shell: bash
        run: |
          set -euo pipefail
          echo "DOCKER_REPO=${{ env.DOCKER_REPO }}"
          if ! jf rt curl -sf -XGET "/api/repositories/${{ env.DOCKER_REPO }}" > repo.json; then
            echo "::error::Artifactory Docker repo '${{ env.DOCKER_REPO }}' not found at ${{ vars.JF_URL }}"
            exit 1
          fi
          if command -v jq >/dev/null; then
            jq '{key,packageType,type}' repo.json
          else
            cat repo.json
          fi
          {
            echo "### JFrog Settings"
            echo "- **JF_URL**: \`${{ vars.JF_URL }}\`"
            echo "- **DOCKER_REPO**: \`${{ env.DOCKER_REPO }}\`"
          } >> "$GITHUB_STEP_SUMMARY"

      # ---------- Source scan: SAST / Secrets / IaC (non-blocking) ----------
      - name: Scan repository (non-blocking)
        shell: bash
        run: jf scan . --fail=false --format "${{ env.XRAY_FORMAT }}"

      # ---------- Build Docker image ----------
      - name: Compose image tags
        id: tags
        shell: bash
        run: |
          NAME="notes-api"
          SHA_TAG="${{ env.JF_REGISTRY }}/${{ env.DOCKER_REPO }}/${NAME}:${GITHUB_SHA}"
          SAFE_BRANCH=$(echo "${GITHUB_REF_NAME:-main}" | tr '/ ' '--')
          REF_TAG="${{ env.JF_REGISTRY }}/${{ env.DOCKER_REPO }}/${NAME}:${SAFE_BRANCH}"
          echo "sha_tag=${SHA_TAG}" >> "$GITHUB_OUTPUT"
          echo "ref_tag=${REF_TAG}" >> "$GITHUB_OUTPUT"

      - name: Build image (local)
        shell: bash
        run: |
          docker build -t "${{ steps.tags.outputs.sha_tag }}" -t "${{ steps.tags.outputs.ref_tag }}" .

      # ---------- Image scan (local) with tar fallback ----------
      - name: Image scan (local; fallback to tar)
        shell: bash
        run: |
          set -euo pipefail
          IMG="${{ steps.tags.outputs.sha_tag }}"
          echo "Verifying local image: ${IMG}"
          if docker inspect "${IMG}" >/dev/null 2>&1; then
            echo "Scanning with Xray (local daemon)…"
            jf scan "docker://${IMG}" --fail=false --format "${{ env.XRAY_FORMAT }}" || {
              echo "Direct scan failed; saving image to tar and scanning tar as fallback…"
              docker save "${IMG}" -o image.tar
              jf scan "image.tar" --fail=false --format "${{ env.XRAY_FORMAT }}"
            }
          else
            echo "::warning::Local image '${IMG}' not found; skipping pre-push scan."
          fi

      # ---------- Push via modern wrapper (no deprecated warning) ----------
      - name: Push image & record build-info
        env:
          BUILD_NAME: ${{ env.BUILD_NAME }}
          BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
        shell: bash
        run: |
          jf docker push "${{ steps.tags.outputs.sha_tag }}" --repo "${{ env.DOCKER_REPO }}" \
            --build-name "${BUILD_NAME}" --build-number "${BUILD_NUMBER}"
          jf docker push "${{ steps.tags.outputs.ref_tag }}" --repo "${{ env.DOCKER_REPO }}" \
            --build-name "${BUILD_NAME}" --build-number "${BUILD_NUMBER}"

      # ---------- Publish build-info ----------
      - name: Publish build-info
        env:
          BUILD_NAME: ${{ env.BUILD_NAME }}
          BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
        shell: bash
        run: jf rt build-publish "${BUILD_NAME}" "${BUILD_NUMBER}"

      # ---------- Xray Build Scan (policy-gated) ----------
      - name: Scan published build (policy-gated)
        env:
          BUILD_NAME: ${{ env.BUILD_NAME }}
          BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          FAIL_ON_SEVERITY: ${{ env.FAIL_ON_SEVERITY }}
        shell: bash
        run: |
          if [ "${FAIL_ON_SEVERITY}" = "none" ]; then
            jf bs "${BUILD_NAME}" "${BUILD_NUMBER}" || true
          else
            jf bs "${BUILD_NAME}" "${BUILD_NUMBER}" --fail-on-severity "${FAIL_ON_SEVERITY}"
          fi
